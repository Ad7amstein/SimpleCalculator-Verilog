module half_adder(
    output sum,
    output carry,
    input a,
    input b
);

    xor(sum, a, b);
    and(carry, a, b);

endmodule

module full_adder(
    output sum,
    output cout,
    input a,
    input b,
    input cin
);

    wire s0, c0, c1;

    half_adder h1(s0, c0, a, b);
    half_adder h2(sum, c1, s0, cin);
    or(cout, c1, c0);

endmodule

module multiplexer4X1(
    output y,
    input i0,
    input i1,
    input i2,
    input i3,
    input s0,
    input s1
);

    wire w1, w2, w3, w4, w5, w6;

    not(w6, s0);
    not(w5, s1);
    and(w1, i0, w5, w6);
    and(w2, i1, w5, s0);
    and(w3, i2, s1, w6);
    and(w4, i3, s1, s0);
    or(y, w1, w2, w3, w4);

endmodule

module SimpleCalculator(
    output g1,
    output g2,
    output g3,
    output cout,
    input a0,
    input a1,
    input a2,
    input b0,
    input b1,
    input b2,
    input s0,
    input s1
);

    wire w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11;

    multiplexer4X1 m1(w1, a0, a0, a0, b0, s0, s1);
    multiplexer4X1 m2(w2, 1'b1, b0, b0, 1'b1, s0, s1);
    multiplexer4X1 m3(w3, a1, a1, a1, b1, s0, s1);
    multiplexer4X1 m4(w4, 1'b0, b1, b1, 1'b0, s0, s1);
    multiplexer4X1 m5(w5, a2, a2, a2, b2, s0, s1);
    multiplexer4X1 m6(w6, 1'b0, b2, b2, 1'b0, s0, s1);
    xor(w7, s1, w1);
    xor(w8, s1, w3);
    xor(w9, s1, w5);
    full_adder f1(g1, w10, s1, w7, w2);
    full_adder f2(g2, w11, w10, w8, w4);
    full_adder f3(g3, cout, w11, w9, w6);

endmodule


module calculator_tb();

    reg clk;
    reg reset;
    reg signed [2:0] a, b;
    reg [2:0] s;
    wire g1, g2, g3, cout;
    reg signed [2:0] g;

    SimpleCalculator calc(g1, g2, g3, cout, a[0], a[1], a[2], b[0], b[1], b[2], s[0], s[1]);

    initial begin
        // Initialize signals
        clk = 0;
        reset = 0;
        a = 3'b000;
        b = 3'b000;
        s = 3'b000;

        // Apply reset
        #10 reset = 1;
        #10 reset = 0;

        // Generate all possible combinations of inputs using for loop
        // a and b can take values from -4 to 3, and s can take values from 0 to 3
        // Verilog's for loop automatically increments the loop variable over time
        for (integer i = -4; i <= 3; i = i + 1) begin
            a = i;
            // Assign values to inputs
            for (integer j = -4; j <= 3; j = j + 1) begin
                b = j;
                for (integer k = 0; k < 4; k = k + 1) begin
                    s = k;
                    // Apply inputs and clock
                    #10 clk = ~clk;

                    // Evaluate g_int as an integer from g1, g2, g3
                    g[0] = g1; g[1] = g2; g[2] = g3;

                    // Display the results
                    $display("a = %b%b%b (%d), b = %b%b%b (%d), s = %b%b (%d), g = %b%b%b (%d), cout = %b", a[2], a[1], a[0], a, b[2], b[1], b[0], b, s[1], s[0], s, g3, g2, g1, g, cout);

                    // Add some delay before changing inputs
                    #10;
                end
            end
        end

        // Finish simulation after all combinations are tested
        #10 $finish;
    end

    always #5 clk = ~clk;  // Toggle clock every 5 time units

endmodule
